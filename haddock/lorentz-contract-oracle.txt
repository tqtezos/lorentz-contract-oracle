-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/tqtezos/lorentz-contract-oracle#readme</a>
@package lorentz-contract-oracle
@version 0.2.0.0

module Data.Functor.Timestamped

-- | Zero or more, but drop the results
many_ :: Alternative f => f a -> f ()

-- | A value with a <a>Timestamp</a>
data Timestamped a
Timestamped :: Timestamp -> a -> Timestamped a
[timestamp] :: Timestamped a -> Timestamp
[timeStamped] :: Timestamped a -> a

-- | Wrap <a>Timestamped</a>
toTimestamped :: forall a s. (Timestamp & (a & s)) :-> (Timestamped a & s)

-- | Unwrap <a>Timestamped</a>
unTimestamped :: forall a s. (Timestamped a & s) :-> ((Timestamp, a) & s)

-- | <a>unTimestamped</a> <a>&gt;&gt;</a> <a>car</a>
getTimestamp :: (Timestamped a & s) :-> (Timestamp & s)

-- | Assert timestamp is strictly before now
assertBeforeNow_ :: (Timestamped a & s) :-> s

-- | <a>assertBeforeNow_</a>, but keep the <a>Timestamped</a> value
assertBeforeNow :: (Timestamped a & s) :-> (Timestamped a & s)

-- | Assert the <a>Timestamped</a> value at the head of the stack is
--   strictly newer (new_value, previous_value)
assertNewer_ :: (Timestamped a & (Timestamped a' & s)) :-> s

-- | Duplicate the first two values on the stack
dupPair :: (a & (b & s)) :-> (a & (b & (a & (b & s))))

-- | <a>assertNewer_</a>, but keep the <a>Timestamped</a> values
assertNewer :: (Timestamped a & (Timestamped a' & s)) :-> (Timestamped a & (Timestamped a' & s))
instance Data.Traversable.Traversable Data.Functor.Timestamped.Timestamped
instance Data.Foldable.Foldable Data.Functor.Timestamped.Timestamped
instance GHC.Base.Functor Data.Functor.Timestamped.Timestamped
instance GHC.Generics.Generic1 Data.Functor.Timestamped.Timestamped
instance GHC.Generics.Generic (Data.Functor.Timestamped.Timestamped a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Functor.Timestamped.Timestamped a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Functor.Timestamped.Timestamped a)
instance Michelson.Typed.Haskell.Value.IsoValue a => Michelson.Typed.Haskell.Value.IsoValue (Data.Functor.Timestamped.Timestamped a)
instance Lorentz.TypeAnns.HasTypeAnn a => Lorentz.TypeAnns.HasTypeAnn (Data.Functor.Timestamped.Timestamped a)
instance GHC.Read.Read Tezos.Core.Timestamp

module Data.Functor.WithCounter

-- | A value with a <a>Natural</a> counter
data WithCounter a
WithCounter :: !Natural -> !a -> WithCounter a
[counter] :: WithCounter a -> !Natural
[value] :: WithCounter a -> !a

-- | Convert <a>WithCounter</a> to <tt><a>Writer</a> (<a>Sum</a>
--   <a>Natural</a>)</tt>.
--   
--   Used to define the <a>Monad</a> instance
toWriter :: WithCounter a -> Writer (Sum Natural) a

-- | Convert <tt><a>Writer</a> (<a>Sum</a> <a>Natural</a>)</tt> to
--   <a>WithCounter</a>.
--   
--   Used to define the <a>Monad</a> instance
unWriter :: Writer (Sum Natural) a -> WithCounter a

-- | Parse a natural number argument, given its field name
parseNatural :: String -> Parser Natural

-- | Parse a <a>Natural</a> counter and value, given a <a>Parser</a> for
--   the value
parseWithCounter :: Parser a -> Parser (WithCounter a)

-- | Wrap <a>WithCounter</a>
toWithCounter :: forall a s. (Natural & (a & s)) :-> (WithCounter a & s)

-- | Unwrap <a>WithCounter</a>
unWithCounter :: forall a s. (WithCounter a & s) :-> ((Natural, a) & s)

-- | Assert the counter matches the given value
assertWithCounter_ :: (WithCounter a & (Natural & s)) :-> (a & s)

-- | Increment the counter
incrementCounter :: (WithCounter a & s) :-> (WithCounter a & s)
instance Data.Traversable.Traversable Data.Functor.WithCounter.WithCounter
instance Data.Foldable.Foldable Data.Functor.WithCounter.WithCounter
instance GHC.Base.Functor Data.Functor.WithCounter.WithCounter
instance GHC.Generics.Generic1 Data.Functor.WithCounter.WithCounter
instance GHC.Generics.Generic (Data.Functor.WithCounter.WithCounter a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Functor.WithCounter.WithCounter a)
instance GHC.Show.Show a => GHC.Show.Show (Data.Functor.WithCounter.WithCounter a)
instance Michelson.Typed.Haskell.Value.IsoValue a => Michelson.Typed.Haskell.Value.IsoValue (Data.Functor.WithCounter.WithCounter a)
instance GHC.Base.Applicative Data.Functor.WithCounter.WithCounter
instance GHC.Base.Monad Data.Functor.WithCounter.WithCounter

module Language.Haskell.TH.Orphans
instance Language.Haskell.TH.Syntax.Lift (Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp)

module Lorentz.Contracts.Oracle

-- | Assert sender is the given address or fail with an error
assertAdmin_ :: (Address & s) :-> s

-- | <a>assertAdmin_</a>, but preserve the stack
assertAdmin :: (Address & s) :-> (Address & s)
data Parameter a
GetValue :: View () a -> Parameter a
[viewValue] :: Parameter a -> View () a
UpdateValue :: a -> Parameter a
[newValue] :: Parameter a -> a
UpdateAdmin :: Address -> Parameter a
[newAdmin] :: Parameter a -> Address

-- | Wrap <a>UpdateValue</a>
toUpdateValue :: forall a s. KnownValue a => (a & s) :-> (Parameter a & s)

-- | Wrap <a>UpdateAdmin</a>
toUpdateAdmin :: forall a s. KnownValue a => (Address & s) :-> (Parameter a & s)
data Storage a
Storage :: a -> Address -> Storage a
[currentValue] :: Storage a -> a
[admin] :: Storage a -> Address

-- | Wrap <a>Storage</a>
toStorage :: (a & (Address & s)) :-> (Storage a & s)

-- | Unwrap <a>Storage</a>
unStorage :: (Storage a & s) :-> ((a, Address) & s)
oracleContract :: forall a. NiceParameter a => (forall s. (a & (a & s)) :-> (a & (a & s))) -> ContractCode (Parameter a) (Storage a)
getValue :: forall a. NiceParameter a => Entrypoint (View () a) (Storage a)
updateValue :: forall a. () => (forall s. (a & (a & s)) :-> (a & (a & s))) -> Entrypoint a (Storage a)
updateAdmin :: Entrypoint Address (Storage a)
uncheckedOracleContract :: forall a. NiceParameter a => ContractCode (Parameter a) (Storage a)
timestampedOracleContract :: forall a. NiceParameter a => ContractCode (Parameter (Timestamped a)) (Storage (Timestamped a))
instance Data.Traversable.Traversable Lorentz.Contracts.Oracle.Storage
instance Data.Foldable.Foldable Lorentz.Contracts.Oracle.Storage
instance GHC.Base.Functor Lorentz.Contracts.Oracle.Storage
instance GHC.Generics.Generic1 Lorentz.Contracts.Oracle.Storage
instance GHC.Generics.Generic (Lorentz.Contracts.Oracle.Storage a)
instance GHC.Generics.Generic1 Lorentz.Contracts.Oracle.Parameter
instance GHC.Generics.Generic (Lorentz.Contracts.Oracle.Parameter a)
instance GHC.Show.Show a => GHC.Show.Show (Lorentz.Contracts.Oracle.Parameter a)
instance Michelson.Typed.Haskell.Value.IsoValue a => Michelson.Typed.Haskell.Value.IsoValue (Lorentz.Contracts.Oracle.Parameter a)
instance GHC.Show.Show a => GHC.Show.Show (Lorentz.Contracts.Oracle.Storage a)
instance Michelson.Typed.Haskell.Value.IsoValue a => Michelson.Typed.Haskell.Value.IsoValue (Lorentz.Contracts.Oracle.Storage a)
instance (Michelson.Typed.Haskell.Value.IsoValue a, Lorentz.TypeAnns.HasTypeAnn a) => Lorentz.EntryPoints.Core.ParameterHasEntryPoints (Lorentz.Contracts.Oracle.Parameter a)

module Lorentz.Contracts.Oracle.CmdLnArgs

-- | Parse something between the two given <a>Lexeme</a>'s
betweenChars :: Char -> Char -> ReadP a -> ReadP a

-- | Parse something in parentheses
inParensP :: ReadP a -> ReadP a

-- | Parse something in double-quotes: <tt>"[something]"</tt>
inQuotesP :: ReadP a -> ReadP a

-- | Attempt to parse with given modifier, otherwise parse without
maybeLiftP :: (ReadP a -> ReadP a) -> ReadP a -> ReadP a

-- | Attempt to parse <a>inParensP</a>, else parse without
maybeInParensP :: ReadP a -> ReadP a

-- | Attempt to parse <a>inQuotesP</a>, else parse without
maybeInQuotesP :: ReadP a -> ReadP a

-- | Read an <a>Address</a>, inside or outside of <tt>""</tt>'s
readAddressP :: ReadP Address

-- | Parse an <a>Address</a> argument, given its field name
parseAddress :: String -> Parser Address

-- | Parse whether to output on one line
onelineOption :: Parser Bool

-- | Parse the output <a>FilePath</a>
outputOptions :: Parser (Maybe FilePath)
assertOpAbsense :: forall (t :: T) a. SingI t => (HasNoOp t => a) -> a
assertBigMapAbsense :: forall (t :: T) a. SingI t => (HasNoBigMap t => a) -> a
assertNestedBigMapsAbsense :: forall (t :: T) a. SingI t => (HasNoNestedBigMaps t => a) -> a
assertContractAbsense :: forall (t :: T) a. SingI t => (HasNoContract t => a) -> a
singTypeableCT :: forall (t :: CT). Sing t -> Dict (Typeable t)
singTypeableT :: forall (t :: T). Sing t -> Dict (Typeable t)
singICT :: forall (t :: CT). Sing t -> Dict (SingI t)
singIT :: forall (t :: T). Sing t -> Dict (SingI t)
data CmdLnArgs
Print :: SomeSing T -> Maybe FilePath -> Bool -> CmdLnArgs
PrintTimeStamped :: SomeSing T -> Maybe FilePath -> Bool -> CmdLnArgs
Init :: SomeContractParam -> Address -> CmdLnArgs
[currentValue] :: CmdLnArgs -> SomeContractParam
[admin] :: CmdLnArgs -> Address
GetValue :: Address -> CmdLnArgs
[callbackContract] :: CmdLnArgs -> Address
UpdateValue :: SomeContractParam -> CmdLnArgs
[newValue] :: CmdLnArgs -> SomeContractParam
UpdateAdmin :: Address -> CmdLnArgs
[newAdmin] :: CmdLnArgs -> Address
unExplicitType :: Type -> T
fromUntypedComparable :: Comparable -> CT
fromUntypedT' :: Type -> T
fromUntypedT :: T -> T

-- | Parse some <a>T</a>
parseSomeT :: String -> Parser (SomeSing T)

-- | A contract parameter with some type
data SomeContractParam
[SomeContractParam] :: (SingI t, Typeable t) => Value t -> (Sing t, Notes t) -> (Dict (HasNoOp t), Dict (HasNoBigMap t)) -> SomeContractParam

-- | Consume <a>SomeContractParam</a>
fromSomeContractParam :: SomeContractParam -> (forall t. (SingI t, Typeable t, HasNoOp t, HasNoBigMap t) => Value t -> r) -> r

-- | Parse and typecheck a Michelson value
parseTypeCheckValue :: forall t. SingI t => Parser (Value t)
parseSomeContractParam :: String -> Parser SomeContractParam
argParser :: Parser CmdLnArgs
infoMod :: InfoMod CmdLnArgs

-- | f = maybe TL.putStrLn writeFileUtf8 mOutput
runCmdLnArgs :: (Maybe FilePath -> Text -> r) -> CmdLnArgs -> r
instance Michelson.Typed.Haskell.Value.IsoValue (Michelson.Typed.Value.Value' Michelson.Typed.Instr.Instr t)
instance Data.Singletons.Internal.SingI t => Lorentz.TypeAnns.HasTypeAnn (Michelson.Typed.Value.Value' Michelson.Typed.Instr.Instr t)
instance GHC.Read.Read Tezos.Address.Address
